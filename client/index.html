<html>
	<head>
		<title>Tree Shaders</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<!-- for some reason non-minified three won't work on my system -->
		<script src="//cdn.rawgit.com/mrdoob/three.js/master/build/three.min.js"></script>
		<!-- dat.gui for controls -->
		<script src="./js/dat.gui.min.js"></script>
		<!-- copy-pasted for quicker dev -->
		<script src="./js/PLYLoader.js"></script>
		<!-- camera controls for development -->
		<script src="./js/OrbitControls.js"></script>

		<!-- vertex shader -->
		<script type="x-shader/x-vertex" id="vertexShader" src="./shaders/trees_vs.glsl"></script>

		<!-- fragment shader -->
		<script type="x-shader/x-fragment" id="fragmentShader" src="./shaders/trees_fs.glsl"></script>

		<script>
		var TreesDef = {
			types: [
				{
					name: "Test",
					fileName: "points.ply",
				},
						{
					name: "ThreeTrees",
					fileName: "3tress_2.ply"
				},
				 {
					name: "palm",
					fileName: "palm.ply"
				},
				 {
					name: "single",
					fileName: "singleTree.ply"
				},
					{
					name: "bush",
					fileName: "bush.ply"
				}
			],
			instances: [
			
				 {
					type: "ThreeTrees",
					position: [4,22,14],
					rotateX: -10,
					scale: 4.3
				},
				//  {
				//     type: "ThreeTrees",
				//     position: [4,22,14],
				//     rotateX: -10,
				//     scale: 4
				// },
				//  {
				//     type: "ThreeTrees",
				//     position: [42,24,2],
				//     rotateX: 0,
				//     scale: 4.4
				// }, 
				{
					type: "ThreeTrees",
					position: [43,24,3],
					rotateX: 0,
					scale: 4.4
				},
				{
					type: "ThreeTrees",
					position: [40,24,2],
					rotateX: 0,
					scale: 4.4
				},
				{
					type: "ThreeTrees",
					position: [20,24,-23],
					rotateX: 80,
					scale: 4.4
				},
			  {
					type: "ThreeTrees",
					position: [30,24,-20],
					rotateX: 20,
					scale: 4.4
				},

		 {
					type: "ThreeTrees",
					position: [30,24,-20],
					rotateX: 60,
					scale: 4.4
				},

		 {
					type: "ThreeTrees",
					position: [30,24,-20],
					rotateX: 60,
					scale: 4.4
				},
			{
					type: "ThreeTrees",
					position: [6,23,-10],
					rotateX: 180,
					scale: 4.4
				},
		   
			{
					type: "ThreeTrees",
					position: [-20,26,-20],
					rotateX: -30,
					scale: 4
				},
		   

			
			
				{
					type: "palm",
					position: [-18,16,10],
					rotateX: -100,
					scale: 3
				},

				{
					type: "palm",
					position: [8,22,6],
					rotateX: 60,
					scale: 3
				},
				 {
					type: "palm",
					position: [-38,20,-32],
					rotateX: 60,
					scale: 3.8
				},
				// {
				//     type: "single",
				//     position: [-52,18,2],
				//     rotateX: 100,
				//     scale: 3
				// },


				// {
				//     type: "single",
				//     position: [20,18,8],
				//     rotateX: 100,
				//     scale: 3
				// }
		   
			]
		};

		// here's the uniforms we'll need for the ShaderMaterial
		var uniforms = { 
			time: { type: "f", value: 0 },
			speedFactor: { type: "f", value: 1.0 },
			pointSize: { type: "f", value: 2.0 },
			bendFactor: { type: "f", value: 0.05 },
			bendHeightLimit: { type: "f", value: 0.0 },
			wind: { type: "v2", value: new THREE.Vector2 ( 1.0, 0.5 ) },
			rustleHeightLimit: { type: "f", value: 5.0 },
			rustleColorCheck: { type: "b", value: false },
			rustleFactor: { type: "f", value: 4.0 },
			rustleFrequency: { type: "f", value: 0.2 }
		};

		// again a bit dirty
		const TREES_PATH = "./trees";

		class Trees extends THREE.Object3D {
				constructor() {
					super();
				}

				init(loadingManager) {
					console.log("init trees loadingmanager");
					let treeTypes = {};
					this.treesLoader = new THREE.PLYLoader(loadingManager);

					return new Promise((resolve, reject) => {
						console.log("Loading trees", TreesDef)
						let typePromises = TreesDef.types.map((type) => {return this.loadType(type, treeTypes)});
						Promise.all(typePromises)
						.then((results) => {
							// this is the ShaderMaterial we need to use for the trees 
							var material = new THREE.ShaderMaterial( {
								uniforms: uniforms,
								vertexColors: THREE.VertexColors,
								vertexShader: document.getElementById( 'vertexShader' ).textContent,
								fragmentShader: document.getElementById( 'fragmentShader' ).textContent
							} );
							// end of interesting stuff
							TreesDef.instances.forEach((instance) => {
								let mesh = new THREE.Points( treeTypes[instance.type], material );
								mesh.position.fromArray(instance.position);
								mesh.scale.set(0.25 * instance.scale, 0.25 * instance.scale, 0.25 * instance.scale);
								mesh.rotateZ(90 * Math.PI / 180);
								mesh.rotateX(instance.rotateX * Math.PI / 180);
								this.add(mesh);
								resolve();
							})
						});
					});      
				}

				loadType(props,store) {
					return new Promise((resolve, reject) => {
						console.log("Loading tree type ", props);
						this.treesLoader.load(TREES_PATH + "/" + props.fileName ,( geometry ) => {
							store[props.name] = geometry;
							resolve();
						});
					});
				}
			}

			this.loadingManager = new THREE.LoadingManager();

			// set up the scene & camera
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 60, window.innerWidth/window.innerHeight, 0.1, 1000 );
			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
			camera.position.x = 0;
			camera.position.y = 40;
			camera.position.z = 0;
			camera.lookAt( new THREE.Vector3( 15, 40, 15 ) );
			controls = new THREE.OrbitControls( camera, renderer.domElement );
			controls.target.set( 15, 40, 15 );

			// load & add the trees
			var trees = new Trees();
			trees.init(loadingManager);
			scene.add( trees );

			// dat.gui
			window.onload = function() {
				var gui = new dat.GUI();
				var fa = gui.addFolder('common');
				var fa0 = fa.addFolder('speedFactor');
				fa0.add(uniforms.speedFactor, 'value', -5, 5);
				var fa1 = fa.addFolder('pointSize');
				fa1.add(uniforms.pointSize, 'value', 0, 5);

				var fb = gui.addFolder('bending');
				var fb0 = fb.addFolder('bendFactor');
				fb0.add(uniforms.bendFactor, 'value', -0.5, 0.5);
				var fb1 = fb.addFolder('wind'); // couldn't get wind gui working b/c js doesn't really have vec2s
				var fb2 = fb.addFolder('bendHeightLimit');
				fb2.add(uniforms.bendHeightLimit, 'value', -50, 50);
				
				var fc = gui.addFolder('rustling');
				var fc0 = fc.addFolder('rustleHeightLimit');
				fc0.add(uniforms.rustleHeightLimit, 'value', -50, 50);
				var fc1 = fc.addFolder('rustleColorCheck');
				fc1.add(uniforms.rustleColorCheck, 'value', 0, 1);
				var fc2 = fc.addFolder('rustleFactor');
				fc2.add(uniforms.rustleFactor, 'value', 0, 10);
				var fc3 = fc.addFolder('rustleFrequency');
				fc3.add(uniforms.rustleFrequency, 'value', 0, 2);
			};

			// we need to pass delta time to the shader so we need a clock
			var clock = new THREE.Clock();
			clock.start();

			var render = function () {
				requestAnimationFrame( render );
				renderer.render(scene, camera);

				// update time
				var delta = clock.getDelta();
				uniforms.time.value += delta;
			};

			render();

		</script>
	</body>
</html>