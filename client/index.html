<html>
	<head>
		<title>Tree Shaders</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<!-- for some reason non-minified three won't work on my system -->
		<script src="//cdn.rawgit.com/mrdoob/three.js/master/build/three.min.js"></script>
		<!-- dat.gui for controls -->
		<script src="./js/dat.gui.min.js"></script>
		<!-- copy-pasted for quicker dev -->
		<script src="./js/PLYLoader.js"></script>
		<!-- camera controls for development -->
		<script src="./js/OrbitControls.js"></script>

		<!-- vertex shader -->
		<script type="x-shader/x-vertex" id="vertexShader">

			// frequencies for rustling animation
			// can be tweaked to taste
			#define SIDE_TO_SIDE_FREQ1 1.975
			#define SIDE_TO_SIDE_FREQ2 0.793
			#define UP_AND_DOWN_FREQ1 0.375
			#define UP_AND_DOWN_FREQ2 0.193
			
			varying vec3 vColor;

			// uniforms
			uniform float time;
			uniform float bendAmount;
			uniform float speedFactor;
			uniform float heightLimit;
			uniform float pointSize;
			uniform vec2 wind;
			uniform float rustleHeightLimit;
			uniform bool rustleColorCheck;
			uniform float rustleFactor;
			uniform float rustleFrequency;

			// functions
			void bend(inout vec3);
			void rustle(inout vec3);
			vec3 rgb2hsv(vec3);
			vec3 hsv2rgb(vec3);
			float smoothCurve(float);
			float triangleWave(float);
			float smoothTriangleWave(float);
			vec4 smoothTriangleWave(vec4);
			
			void main(void) {
				vColor = color;
				float length = length(position.xyz);
				vec3 pos = position;
				bend(pos);
				rustle(pos);
				gl_PointSize = pointSize;
				gl_Position = projectionMatrix * modelViewMatrix * vec4(normalize(pos.xyz) * length, 1.0);
			}

			void bend(inout vec3 pos) {
				if(pos.x > heightLimit) {
				float bend = (sin(time * speedFactor) + 1.0) * bendAmount;
				float clampedX = max(pos.x, heightLimit); // coordinate system is rotated -> x is up
				float bf = (clampedX - heightLimit) * bend;
					vec3 newPos = pos;
					newPos.yz += wind.xy * bf; // trees' supposed xz plane is yz b/c rotation
					pos = newPos;
				}
			}

			void rustle(inout vec3 pos) {
				vec3 hsv = rgb2hsv(color);
				// values by trial and error, mostly
				if(pos.x > rustleHeightLimit) {
					if(!rustleColorCheck || (hsv.x > 0.16 && hsv.x < 0.5 && hsv.y > 0.18 && hsv.z > 0.08)) {
						// vColor.r = 1.0; // uncomment to debug hsv comparisons
						// vColor.g = 0.0;
						// vColor.b = 0.0;
						vec3 newPos = pos;
						float objPhase = length(modelMatrix[3].xyz); // assign unique phase to each object
						float vtxYPhase = pos.y + objPhase; // vary vertex phases according to location
						float vtxZPhase = pos.z + objPhase; // on the yz plane (ground plane b/c rotated models)
						vec2 wavesIn = vec2(vtxYPhase + time, vtxZPhase + time);
						vec4 waves = (fract(wavesIn.xxyy *
						   vec4(SIDE_TO_SIDE_FREQ1, SIDE_TO_SIDE_FREQ2, UP_AND_DOWN_FREQ1, UP_AND_DOWN_FREQ2)) *
						   2.0 - 1.0 ) * speedFactor * rustleFrequency; // lifted from crytek paper: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch16.html
						waves = smoothTriangleWave(waves);
						vec2 wavesSum = waves.xz + waves.yw;  
						newPos.y += wavesSum.y * (pos.x - rustleHeightLimit) * rustleFactor / 100.0;
						newPos.z += wavesSum.x * (pos.x - rustleHeightLimit) * rustleFactor / 100.0;
						pos = newPos;
					}
				}
			}

			// run-of-the-mill rgb-hsv-conversions
			vec3 rgb2hsv(vec3 c) {
				vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
				vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
				vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

				float d = q.x - min(q.w, q.y);
				float e = 1.0e-10;
				return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
			}

			vec3 hsv2rgb(vec3 c) {
				vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
				vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
				return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
			}

			// general math
			float smoothCurve(float x) {  
				return x * x * (3.0 - 2.0 * x);  
			}  
			float triangleWave(float x) {  
				return abs(fract(x + 0.5) * 2.0 - 1.0);  
			}  
			float smoothTriangleWave(float x) {  
				return smoothCurve(triangleWave(x) );  
			}
			vec4 smoothTriangleWave(vec4 v) {
				float x = smoothTriangleWave(v.x);
				float y = smoothTriangleWave(v.y);
				float z = smoothTriangleWave(v.z);
				float w = smoothTriangleWave(v.w);
				return vec4(x, y, z, w);
			}
		</script>

		<!-- fragment shader -->
		<script type="x-shader/x-fragment" id="fragmentShader">
			varying vec3 vColor;

			void main() {
				gl_FragColor = vec4(vColor.rgb, 1.0);
			}
		</script>

		<script>
		// sorry for the copy-paste, was the fastest way to get everything up & running		
		var TreesDef = {
			types: [
				{
					name: "Test",
					fileName: "points.ply",
				},
						{
					name: "ThreeTrees",
					fileName: "3tress_2.ply"
				},
				 {
					name: "palm",
					fileName: "palm.ply"
				},
				 {
					name: "single",
					fileName: "singleTree.ply"
				},
					{
					name: "bush",
					fileName: "bush.ply"
				}
			],
			instances: [
			
				 {
					type: "ThreeTrees",
					position: [4,22,14],
					rotateX: -10,
					scale: 4.3
				},
				//  {
				//     type: "ThreeTrees",
				//     position: [4,22,14],
				//     rotateX: -10,
				//     scale: 4
				// },
				//  {
				//     type: "ThreeTrees",
				//     position: [42,24,2],
				//     rotateX: 0,
				//     scale: 4.4
				// }, 
				{
					type: "ThreeTrees",
					position: [43,24,3],
					rotateX: 0,
					scale: 4.4
				},
				{
					type: "ThreeTrees",
					position: [40,24,2],
					rotateX: 0,
					scale: 4.4
				},
				{
					type: "ThreeTrees",
					position: [20,24,-23],
					rotateX: 80,
					scale: 4.4
				},
			  {
					type: "ThreeTrees",
					position: [30,24,-20],
					rotateX: 20,
					scale: 4.4
				},

		 {
					type: "ThreeTrees",
					position: [30,24,-20],
					rotateX: 60,
					scale: 4.4
				},

		 {
					type: "ThreeTrees",
					position: [30,24,-20],
					rotateX: 60,
					scale: 4.4
				},
			{
					type: "ThreeTrees",
					position: [6,23,-10],
					rotateX: 180,
					scale: 4.4
				},
		   
			{
					type: "ThreeTrees",
					position: [-20,26,-20],
					rotateX: -30,
					scale: 4
				},
		   

			
			
				{
					type: "palm",
					position: [-18,16,10],
					rotateX: -100,
					scale: 3
				},

				{
					type: "palm",
					position: [8,22,6],
					rotateX: 60,
					scale: 3
				},
				 {
					type: "palm",
					position: [-38,20,-32],
					rotateX: 60,
					scale: 3.8
				},
				// {
				//     type: "single",
				//     position: [-52,18,2],
				//     rotateX: 100,
				//     scale: 3
				// },


				// {
				//     type: "single",
				//     position: [20,18,8],
				//     rotateX: 100,
				//     scale: 3
				// }
		   
			]
		};

		// here's the uniforms we'll need for the ShaderMaterial
		var uniforms = { 
			time: { type: "f", value: 0 },
			bendAmount: { type: "f", value: 0.05 },
			speedFactor: { type: "f", value: 1.0 },
			wind: { type: "v2", value: new THREE.Vector2 ( 1.0, 0.5 ) },
			heightLimit: { type: "f", value: 0.0 },
			pointSize: { type: "f", value: 2.0 },
			rustleHeightLimit: { type: "f", value: 5.0 },
			rustleColorCheck: { type: "b", value: false },
			rustleFactor: { type: "f", value: 4.0 },
			rustleFrequency: { type: "f", value: 0.2 }
		};

		// again a bit dirty
		const TREES_PATH = "./trees";

		class Trees extends THREE.Object3D {
				constructor() {
					super();
				}

				init(loadingManager) {
					console.log("init trees loadingmanager");
					let treeTypes = {};
					this.treesLoader = new THREE.PLYLoader(loadingManager);

					return new Promise((resolve, reject) => {
						console.log("Loading trees", TreesDef)
						let typePromises = TreesDef.types.map((type) => {return this.loadType(type, treeTypes)});
						Promise.all(typePromises)
						.then((results) => {
							// this is the ShaderMaterial we need to use for the trees 
							var material = new THREE.ShaderMaterial( {
								uniforms: uniforms,
								vertexColors: THREE.VertexColors,
								vertexShader: document.getElementById( 'vertexShader' ).textContent,
								fragmentShader: document.getElementById( 'fragmentShader' ).textContent
							} );
							// end of interesting stuff
							TreesDef.instances.forEach((instance) => {
								let mesh = new THREE.Points( treeTypes[instance.type], material );
								mesh.position.fromArray(instance.position);
								mesh.scale.set(0.25 * instance.scale, 0.25 * instance.scale, 0.25 * instance.scale);
								mesh.rotateZ(90 * Math.PI / 180);
								mesh.rotateX(instance.rotateX * Math.PI / 180);
								this.add(mesh);
								resolve();
							})
						});
					});      
				}

				loadType(props,store) {
					return new Promise((resolve, reject) => {
						console.log("Loading tree type ", props);
						this.treesLoader.load(TREES_PATH + "/" + props.fileName ,( geometry ) => {
							store[props.name] = geometry;
							resolve();
						});
					});
				}
			}

			this.loadingManager = new THREE.LoadingManager();

			// set up the scene & camera
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 60, window.innerWidth/window.innerHeight, 0.1, 1000 );
			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
			camera.position.x = 0;
			camera.position.y = 40;
			camera.position.z = 0;
			camera.lookAt( new THREE.Vector3( 15, 40, 15 ) );
			controls = new THREE.OrbitControls( camera, renderer.domElement );
			controls.target.set( 15, 40, 15 );

			// load & add the trees
			var trees = new Trees();
			trees.init(loadingManager);
			scene.add( trees );

			// dat.gui
			window.onload = function() {
				var gui = new dat.GUI();
				var f1 = gui.addFolder('bendAmount');
				f1.add(uniforms.bendAmount, 'value', -0.5, 0.5);
				var f2 = gui.addFolder('speedFactor');
				f2.add(uniforms.speedFactor, 'value', -5, 5);
				var f3 = gui.addFolder('wind');
				//wind: { type: "v2", value: new THREE.Vector2 ( 1.0, 0.5 ) },
				var f4 = gui.addFolder('heightLimit');
				f4.add(uniforms.heightLimit, 'value', -50, 50);
				var f5 = gui.addFolder('pointSize');
				f5.add(uniforms.pointSize, 'value', 0, 5);
				var f6 = gui.addFolder('rustleHeightLimit');
				f6.add(uniforms.rustleHeightLimit, 'value', -50, 50);
				var f7 = gui.addFolder('rustleColorCheck');
				f7.add(uniforms.rustleColorCheck, 'value', 0, 1);
				var f8 = gui.addFolder('rustleFactor');
				f8.add(uniforms.rustleFactor, 'value', 0, 10);
				var f9 = gui.addFolder('rustleFrequency');
				f9.add(uniforms.rustleFrequency, 'value', 0, 2);
			};



			// we need to pass delta time to the shader so we need a clock
			var clock = new THREE.Clock();
			clock.start();

			var render = function () {
				requestAnimationFrame( render );
				renderer.render(scene, camera);

				// update time
				var delta = clock.getDelta();
				uniforms.time.value += delta;
			};

			render();

		</script>
	</body>
</html>